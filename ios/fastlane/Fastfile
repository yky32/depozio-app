# Fastlane Configuration for iOS App Store Deployment
# Documentation: https://docs.fastlane.tools

default_platform(:ios)

# Trigger GitHub Actions workflow

platform :ios do
  desc "List existing distribution certificates"
  lane :list_certificates do
    # Authenticate first if using API key
    api_key_path = nil
    api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
    api_key_issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
    
    if api_key_id
      possible_paths = [
        "#{ENV['HOME']}/private_keys/AuthKey_#{api_key_id}.p8",
        "~/private_keys/AuthKey_#{api_key_id}.p8"
      ].compact
      
      possible_paths.each do |path|
        expanded_path = File.expand_path(path)
        if File.exist?(expanded_path)
          api_key_path = expanded_path
          break
        end
      end
      
      if api_key_path && File.exist?(api_key_path)
        key_content = File.read(api_key_path)
        app_store_connect_api_key(
          key_id: api_key_id,
          issuer_id: api_key_issuer_id,
          key_content: key_content,
          is_key_content_base64: false
        )
      end
    end
    
    UI.message("=== Listing Distribution Certificates ===")
    begin
      get_certificates(
        team_id: "3G34999H3A",
        readonly: true
      )
      UI.success("✓ Certificates found and listed")
    rescue => e
      UI.important("No certificates found or error: #{e.message}")
      UI.important("")
      UI.important("To view certificates in Apple Developer Portal:")
      UI.important("https://developer.apple.com/account/resources/certificates/list")
    end
  end

  desc "Debug: Check environment variables (for troubleshooting)"
  lane :check_env do
    UI.message("=== Environment Variables Check ===")
    UI.message("FASTLANE_USER: #{ENV['FASTLANE_USER'] ? 'SET (' + ENV['FASTLANE_USER'] + ')' : 'NOT SET'}")
    UI.message("FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD: #{ENV['FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD'] ? 'SET' : 'NOT SET'}")
    UI.message("FASTLANE_PASSWORD: #{ENV['FASTLANE_PASSWORD'] ? 'SET' : 'NOT SET'}")
    UI.message("APP_STORE_CONNECT_API_KEY_ID: #{ENV['APP_STORE_CONNECT_API_KEY_ID'] ? 'SET' : 'NOT SET'}")
    UI.message("APP_STORE_CONNECT_ISSUER_ID: #{ENV['APP_STORE_CONNECT_ISSUER_ID'] ? 'SET' : 'NOT SET'}")
    UI.message("APP_STORE_CONNECT_API_KEY_PATH: #{ENV['APP_STORE_CONNECT_API_KEY_PATH'] ? 'SET (' + ENV['APP_STORE_CONNECT_API_KEY_PATH'] + ')' : 'NOT SET'}")
    
    if ENV['APP_STORE_CONNECT_API_KEY_PATH']
      key_exists = File.exist?(File.expand_path(ENV['APP_STORE_CONNECT_API_KEY_PATH']))
      UI.message("API Key file exists: #{key_exists}")
    end
    
    UI.message("Team ID: 3G34999H3A")
    UI.message("App Identifier: com.depozio")
    UI.message("================================")
  end


  desc "Download certificates and provisioning profiles"
  lane :certificates do
    # Check for App Store Connect API key
    api_key_path = nil
    api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
    api_key_issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
    
    if api_key_id
      # Try to find the API key file
      # Don't use ENV["APP_STORE_CONNECT_API_KEY_PATH"] as it might confuse Fastlane's auto-detection
      possible_paths = [
        "#{ENV['HOME']}/private_keys/AuthKey_#{api_key_id}.p8",
        "~/private_keys/AuthKey_#{api_key_id}.p8"
      ].compact
      
      possible_paths.each do |path|
        expanded_path = File.expand_path(path)
        if File.exist?(expanded_path)
          api_key_path = expanded_path
          break
        end
      end
      
      unless api_key_path
        UI.important("API key file not found. Tried: #{possible_paths.join(', ')}")
        UI.important("Falling back to Apple ID authentication")
      end
    end
    
    # Use App Store Connect API key if available, otherwise use username/password
    if api_key_path && File.exist?(api_key_path)
      UI.message("Using App Store Connect API key: #{api_key_path}")
      
      # Verify file content starts with BEGIN PRIVATE KEY
      first_line = File.readlines(api_key_path).first&.strip
      unless first_line == "-----BEGIN PRIVATE KEY-----"
        UI.user_error!("Invalid API key file format. First line should be '-----BEGIN PRIVATE KEY-----', got: #{first_line}")
      end
      
      # Read the key content from file
      key_content = File.read(api_key_path)
      
      unless api_key_issuer_id
        UI.user_error!("APP_STORE_CONNECT_ISSUER_ID must be set when using API key")
      end
      
      # Use app_store_connect_api_key action to authenticate first
      # This sets up the API key for subsequent actions
      app_store_connect_api_key(
        key_id: api_key_id,
        issuer_id: api_key_issuer_id,
        key_content: key_content,
        is_key_content_base64: false
      )
      
      # Unset APP_STORE_CONNECT_API_KEY_PATH to prevent Fastlane from trying to use it
      # We've already authenticated with app_store_connect_api_key, so we don't need the path
      ENV.delete("APP_STORE_CONNECT_API_KEY_PATH")
      
      # Always try to get existing certificates first (readonly mode)
      # This will download existing certificates if they exist, without creating new ones
      certificates_exist = false
      begin
        UI.message("Checking for existing distribution certificates...")
        get_certificates(
          team_id: "3G34999H3A",
          readonly: true
        )
        certificates_exist = true
        UI.success("✓ Existing certificates found and downloaded")
      rescue => e
        error_message = e.message.to_s.downcase
        # Check if error is specifically about no certificates existing
        # vs other errors (network, auth, etc.)
        if error_message.include?("no certificates") || 
           error_message.include?("could not find") ||
           error_message.include?("not found")
          UI.important("No existing distribution certificates found in Apple Developer Portal")
          UI.important("Error: #{e.message}")
          certificates_exist = false
        else
          # Other error (auth, network, etc.) - don't try to create new certificate
          UI.user_error!("Failed to check for existing certificates: #{e.message}")
        end
      end
      
      # Only create a new certificate if we're certain none exist
      # This prevents hitting the certificate limit
      if certificates_exist
        UI.message("Using existing certificate - skipping creation")
      else
        UI.important("⚠️ WARNING: About to create a new distribution certificate")
        UI.important("⚠️ Make sure you've removed old/unused certificates from Apple Developer Portal first")
        UI.important("⚠️ Creating new certificate may fail if you've reached the limit")
        
        begin
          cert(
            team_id: "3G34999H3A"
          )
          UI.success("✓ New certificate created successfully")
        rescue => e
          if e.message.include?("maximum number") || e.message.include?("reached the maximum")
            UI.user_error!("Certificate limit reached! Please remove old certificates from Apple Developer Portal:\n" +
                          "https://developer.apple.com/account/resources/certificates/list\n\n" +
                          "Then retry the workflow.")
          else
            raise
          end
        end
      end
      
      sigh(
        app_identifier: "com.depozio",
        team_id: "3G34999H3A",
        force: true
      )
    else
      UI.message("Using Apple ID authentication")
      
      # Verify credentials are available
      unless ENV["FASTLANE_USER"]
        UI.user_error!("FASTLANE_USER must be set when API key is not available")
      end
      
      unless ENV["FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD"]
        UI.user_error!("FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD must be set for 2FA accounts")
      end
      
      # Set password for fastlane
      ENV["FASTLANE_PASSWORD"] = ENV["FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD"]
      
      # Always try to get existing certificates first (readonly mode)
      # This will download existing certificates if they exist, without creating new ones
      certificates_exist = false
      begin
        UI.message("Checking for existing distribution certificates...")
        get_certificates(
          username: ENV["FASTLANE_USER"],
          team_id: "3G34999H3A",
          readonly: true
        )
        certificates_exist = true
        UI.success("✓ Existing certificates found and downloaded")
      rescue => e
        error_message = e.message.to_s.downcase
        # Check if error is specifically about no certificates existing
        # vs other errors (network, auth, etc.)
        if error_message.include?("no certificates") || 
           error_message.include?("could not find") ||
           error_message.include?("not found")
          UI.important("No existing distribution certificates found in Apple Developer Portal")
          UI.important("Error: #{e.message}")
          certificates_exist = false
        else
          # Other error (auth, network, etc.) - don't try to create new certificate
          UI.user_error!("Failed to check for existing certificates: #{e.message}")
        end
      end
      
      # Only create a new certificate if we're certain none exist
      # This prevents hitting the certificate limit
      if certificates_exist
        UI.message("Using existing certificate - skipping creation")
      else
        UI.important("⚠️ WARNING: About to create a new distribution certificate")
        UI.important("⚠️ Make sure you've removed old/unused certificates from Apple Developer Portal first")
        UI.important("⚠️ Creating new certificate may fail if you've reached the limit")
        
        begin
          cert(
            username: ENV["FASTLANE_USER"],
            team_id: "3G34999H3A"
          )
          UI.success("✓ New certificate created successfully")
        rescue => e
          if e.message.include?("maximum number") || e.message.include?("reached the maximum")
            UI.user_error!("Certificate limit reached! Please remove old certificates from Apple Developer Portal:\n" +
                          "https://developer.apple.com/account/resources/certificates/list\n\n" +
                          "Then retry the workflow.")
          else
            raise
          end
        end
      end
      
      sigh(
        username: ENV["FASTLANE_USER"],
        app_identifier: "com.depozio",
        team_id: "3G34999H3A",
        force: true
      )
    end
  end

  desc "Build and export IPA"
  lane :build do
    # Download certificates first
    certificates
    
    # Get the provisioning profile info from sigh
    profile_path = lane_context[Fastlane::Actions::SharedValues::SIGH_PROFILE_PATH]
    profile_name = lane_context[Fastlane::Actions::SharedValues::SIGH_NAME]
    
    unless profile_path && File.exist?(profile_path)
      UI.user_error!("Provisioning profile not found. Run 'fastlane certificates' first.")
    end
    
    UI.message("Using provisioning profile: #{profile_path}")
    UI.message("Profile name: #{profile_name}")
    
    # Install the provisioning profile to the system
    # This ensures Xcode can find it during the build
    install_provisioning_profile(
      path: profile_path
    )
    
    # Build the app using gym (build_app)
    # The export_options will handle code signing during export
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "../build/ios/ipa",
      clean: true,
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        provisioningProfiles: {
          "com.depozio" => profile_name || "com.depozio AppStore"
        },
        signingStyle: "manual",
        method: "app-store"
      }
    )
  end

  desc "Upload to App Store Connect"
  lane :upload do
    # Find the IPA
    ipa_path = Dir.glob("../build/ios/ipa/*.ipa").first
    
    unless ipa_path
      UI.user_error!("IPA not found. Run 'fastlane build' first.")
    end
    
    UI.message("Uploading: #{ipa_path}")
    
    # Use API key if available - authenticate first
    api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
    api_key_issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
    
    if api_key_id && api_key_issuer_id
      possible_paths = [
        "#{ENV['HOME']}/private_keys/AuthKey_#{api_key_id}.p8",
        "~/private_keys/AuthKey_#{api_key_id}.p8"
      ].compact
      
      api_key_path = nil
      possible_paths.each do |path|
        expanded_path = File.expand_path(path)
        if File.exist?(expanded_path)
          api_key_path = expanded_path
          break
        end
      end
      
      if api_key_path
        key_content = File.read(api_key_path)
        # Authenticate with API key first
        app_store_connect_api_key(
          key_id: api_key_id,
          issuer_id: api_key_issuer_id,
          key_content: key_content,
          is_key_content_base64: false
        )
      end
    end
    
    # Upload will use the authenticated session
    upload_to_app_store(
      ipa: ipa_path,
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false
    )
    
    UI.success("Upload complete!")
  end

  desc "Deploy to App Store (build + upload)"
  lane :deploy do
    build
    upload
  end
end
