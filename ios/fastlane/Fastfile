# Fastlane Configuration for iOS App Store Deployment
# Documentation: https://docs.fastlane.tools

default_platform(:ios)

# Trigger GitHub Actions workflow

platform :ios do
  desc "List existing distribution certificates"
  lane :list_certificates do
    # Authenticate first if using API key
    api_key_path = nil
    api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
    api_key_issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
    
    if api_key_id
      possible_paths = [
        "#{ENV['HOME']}/private_keys/AuthKey_#{api_key_id}.p8",
        "~/private_keys/AuthKey_#{api_key_id}.p8"
      ].compact
      
      possible_paths.each do |path|
        expanded_path = File.expand_path(path)
        if File.exist?(expanded_path)
          api_key_path = expanded_path
          break
        end
      end
      
      if api_key_path && File.exist?(api_key_path)
        key_content = File.read(api_key_path)
        app_store_connect_api_key(
          key_id: api_key_id,
          issuer_id: api_key_issuer_id,
          key_content: key_content,
          is_key_content_base64: false
        )
      end
    end
    
    UI.message("=== Listing Distribution Certificates ===")
    begin
      get_certificates(
        team_id: "3G34999H3A",
        readonly: true
      )
      UI.success("✓ Certificates found and listed")
    rescue => e
      UI.important("No certificates found or error: #{e.message}")
      UI.important("")
      UI.important("To view certificates in Apple Developer Portal:")
      UI.important("https://developer.apple.com/account/resources/certificates/list")
    end
  end

  desc "Debug: Check environment variables (for troubleshooting)"
  lane :check_env do
    UI.message("=== Environment Variables Check ===")
    UI.message("FASTLANE_USER: #{ENV['FASTLANE_USER'] ? 'SET (' + ENV['FASTLANE_USER'] + ')' : 'NOT SET'}")
    UI.message("FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD: #{ENV['FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD'] ? 'SET' : 'NOT SET'}")
    UI.message("FASTLANE_PASSWORD: #{ENV['FASTLANE_PASSWORD'] ? 'SET' : 'NOT SET'}")
    UI.message("APP_STORE_CONNECT_API_KEY_ID: #{ENV['APP_STORE_CONNECT_API_KEY_ID'] ? 'SET' : 'NOT SET'}")
    UI.message("APP_STORE_CONNECT_ISSUER_ID: #{ENV['APP_STORE_CONNECT_ISSUER_ID'] ? 'SET' : 'NOT SET'}")
    UI.message("APP_STORE_CONNECT_API_KEY_PATH: #{ENV['APP_STORE_CONNECT_API_KEY_PATH'] ? 'SET (' + ENV['APP_STORE_CONNECT_API_KEY_PATH'] + ')' : 'NOT SET'}")
    
    if ENV['APP_STORE_CONNECT_API_KEY_PATH']
      key_exists = File.exist?(File.expand_path(ENV['APP_STORE_CONNECT_API_KEY_PATH']))
      UI.message("API Key file exists: #{key_exists}")
    end
    
    UI.message("Team ID: 3G34999H3A")
    UI.message("App Identifier: com.depozio")
    UI.message("================================")
  end


  desc "Download certificates and provisioning profiles"
  lane :certificates do
    # Check for App Store Connect API key
    api_key_path = nil
    api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
    api_key_issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
    
    if api_key_id
      # Try to find the API key file
      # Don't use ENV["APP_STORE_CONNECT_API_KEY_PATH"] as it might confuse Fastlane's auto-detection
      possible_paths = [
        "#{ENV['HOME']}/private_keys/AuthKey_#{api_key_id}.p8",
        "~/private_keys/AuthKey_#{api_key_id}.p8"
      ].compact
      
      possible_paths.each do |path|
        expanded_path = File.expand_path(path)
        if File.exist?(expanded_path)
          api_key_path = expanded_path
          break
        end
      end
      
      unless api_key_path
        UI.important("API key file not found. Tried: #{possible_paths.join(', ')}")
        UI.important("Falling back to Apple ID authentication")
      end
    end
    
    # Use App Store Connect API key if available, otherwise use username/password
    if api_key_path && File.exist?(api_key_path)
      UI.message("Using App Store Connect API key: #{api_key_path}")
      
      # Verify file content starts with BEGIN PRIVATE KEY
      first_line = File.readlines(api_key_path).first&.strip
      unless first_line == "-----BEGIN PRIVATE KEY-----"
        UI.user_error!("Invalid API key file format. First line should be '-----BEGIN PRIVATE KEY-----', got: #{first_line}")
      end
      
      # Read the key content from file
      key_content = File.read(api_key_path)
      
      unless api_key_issuer_id
        UI.user_error!("APP_STORE_CONNECT_ISSUER_ID must be set when using API key")
      end
      
      # Use app_store_connect_api_key action to authenticate first
      # This sets up the API key for subsequent actions
      app_store_connect_api_key(
        key_id: api_key_id,
        issuer_id: api_key_issuer_id,
        key_content: key_content,
        is_key_content_base64: false
      )
      
      # Unset APP_STORE_CONNECT_API_KEY_PATH to prevent Fastlane from trying to use it
      # We've already authenticated with app_store_connect_api_key, so we don't need the path
      ENV.delete("APP_STORE_CONNECT_API_KEY_PATH")
      
      # Use cert action - it will automatically reuse existing certificates from portal
      # and install them into the keychain. Only creates new ones if none exist.
      begin
        UI.message("Getting distribution certificate (will reuse existing if available)...")
        cert(
          team_id: "3G34999H3A"
        )
        UI.success("✓ Certificate ready (reused existing or created new)")
      rescue => e
        error_message = e.message.to_s.downcase
        error_output = e.message
        
        # Check if certificates exist in portal but private keys are missing locally
        if error_output.include?("can't be found on your local computer") ||
           error_output.include?("There are no local code signing identities found")
          UI.important("⚠️ Certificates exist in Apple Developer Portal but private keys are missing locally")
          UI.important("⚠️ This usually means certificates were created on a different machine")
          UI.important("")
          UI.important("Options:")
          UI.important("1. Export certificate with private key from the original machine and add to workflow")
          UI.important("2. Revoke old certificates and create new ones (if under limit)")
          UI.important("")
          UI.important("Since you've hit the certificate limit, you need to:")
          UI.user_error!("Certificate limit reached! Certificates exist in portal but can't be used locally.\n\n" +
                        "Steps to fix:\n" +
                        "1. Go to: https://developer.apple.com/account/resources/certificates/list\n" +
                        "2. Filter by 'Production' to see Distribution certificates\n" +
                        "3. Revoke expired or unused certificates (you have: TDMN54S859, U6AY8DY6XC)\n" +
                        "4. Wait a few minutes for changes to propagate\n" +
                        "5. Retry the workflow - it will create a new certificate with the private key\n\n" +
                        "Note: The existing certificates can't be used because their private keys\n" +
                        "are not available on this machine. After revoking old ones, a new certificate\n" +
                        "will be created with the private key stored locally.")
        elsif error_message.include?("maximum number") || 
             error_message.include?("reached the maximum") ||
             error_message.include?("certificate limit")
          UI.user_error!("Certificate limit reached! Please remove old certificates from Apple Developer Portal:\n" +
                        "https://developer.apple.com/account/resources/certificates/list\n\n" +
                        "Steps to fix:\n" +
                        "1. Go to the link above\n" +
                        "2. Filter by 'Production' to see Distribution certificates\n" +
                        "3. Revoke expired or unused certificates\n" +
                        "4. Wait a few minutes for changes to propagate\n" +
                        "5. Retry the workflow\n\n" +
                        "The cert action will automatically reuse existing certificates if they exist in the portal.")
        else
          # Re-raise other errors
          raise
        end
      end
      
      sigh(
        app_identifier: "com.depozio",
        team_id: "3G34999H3A",
        force: true
      )
    else
      UI.message("Using Apple ID authentication")
      
      # Verify credentials are available
      unless ENV["FASTLANE_USER"]
        UI.user_error!("FASTLANE_USER must be set when API key is not available")
      end
      
      unless ENV["FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD"]
        UI.user_error!("FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD must be set for 2FA accounts")
      end
      
      # Set password for fastlane
      ENV["FASTLANE_PASSWORD"] = ENV["FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD"]
      
      # Use cert action - it will automatically reuse existing certificates from portal
      # and install them into the keychain. Only creates new ones if none exist.
      begin
        UI.message("Getting distribution certificate (will reuse existing if available)...")
        cert(
          username: ENV["FASTLANE_USER"],
          team_id: "3G34999H3A"
        )
        UI.success("✓ Certificate ready (reused existing or created new)")
      rescue => e
        error_message = e.message.to_s.downcase
        error_output = e.message
        
        # Check if certificates exist in portal but private keys are missing locally
        if error_output.include?("can't be found on your local computer") ||
           error_output.include?("There are no local code signing identities found")
          UI.important("⚠️ Certificates exist in Apple Developer Portal but private keys are missing locally")
          UI.important("⚠️ This usually means certificates were created on a different machine")
          UI.important("")
          UI.important("Options:")
          UI.important("1. Export certificate with private key from the original machine and add to workflow")
          UI.important("2. Revoke old certificates and create new ones (if under limit)")
          UI.important("")
          UI.important("Since you've hit the certificate limit, you need to:")
          UI.user_error!("Certificate limit reached! Certificates exist in portal but can't be used locally.\n\n" +
                        "Steps to fix:\n" +
                        "1. Go to: https://developer.apple.com/account/resources/certificates/list\n" +
                        "2. Filter by 'Production' to see Distribution certificates\n" +
                        "3. Revoke expired or unused certificates\n" +
                        "4. Wait a few minutes for changes to propagate\n" +
                        "5. Retry the workflow - it will create a new certificate with the private key\n\n" +
                        "Note: The existing certificates can't be used because their private keys\n" +
                        "are not available on this machine. After revoking old ones, a new certificate\n" +
                        "will be created with the private key stored locally.")
        elsif error_message.include?("maximum number") || 
             error_message.include?("reached the maximum") ||
             error_message.include?("certificate limit")
          UI.user_error!("Certificate limit reached! Please remove old certificates from Apple Developer Portal:\n" +
                        "https://developer.apple.com/account/resources/certificates/list\n\n" +
                        "Steps to fix:\n" +
                        "1. Go to the link above\n" +
                        "2. Filter by 'Production' to see Distribution certificates\n" +
                        "3. Revoke expired or unused certificates\n" +
                        "4. Wait a few minutes for changes to propagate\n" +
                        "5. Retry the workflow\n\n" +
                        "The cert action will automatically reuse existing certificates if they exist in the portal.")
        else
          # Re-raise other errors
          raise
        end
      end
      
      sigh(
        username: ENV["FASTLANE_USER"],
        app_identifier: "com.depozio",
        team_id: "3G34999H3A",
        force: true
      )
    end
  end

  desc "Build and export IPA"
  lane :build do
    # Download certificates first
    certificates
    
    # Get the provisioning profile info from sigh
    profile_path = lane_context[Fastlane::Actions::SharedValues::SIGH_PROFILE_PATH]
    profile_name = lane_context[Fastlane::Actions::SharedValues::SIGH_NAME]
    
    unless profile_path && File.exist?(profile_path)
      UI.user_error!("Provisioning profile not found. Run 'fastlane certificates' first.")
    end
    
    UI.message("Using provisioning profile: #{profile_path}")
    UI.message("Profile name: #{profile_name}")
    
    # Install the provisioning profile to the system
    # This ensures Xcode can find it during the build
    install_provisioning_profile(
      path: profile_path
    )
    
    # Build the app using gym (build_app)
    # The export_options will handle code signing during export
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "../build/ios/ipa",
      clean: true,
      include_bitcode: false,
      include_symbols: true,
      export_options: {
        provisioningProfiles: {
          "com.depozio" => profile_name || "com.depozio AppStore"
        },
        signingStyle: "manual",
        method: "app-store"
      }
    )
  end

  desc "Upload to App Store Connect"
  lane :upload do
    # Find the IPA
    ipa_path = Dir.glob("../build/ios/ipa/*.ipa").first
    
    unless ipa_path
      UI.user_error!("IPA not found. Run 'fastlane build' first.")
    end
    
    UI.message("Uploading: #{ipa_path}")
    
    # Use API key if available - authenticate first
    api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
    api_key_issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
    
    if api_key_id && api_key_issuer_id
      possible_paths = [
        "#{ENV['HOME']}/private_keys/AuthKey_#{api_key_id}.p8",
        "~/private_keys/AuthKey_#{api_key_id}.p8"
      ].compact
      
      api_key_path = nil
      possible_paths.each do |path|
        expanded_path = File.expand_path(path)
        if File.exist?(expanded_path)
          api_key_path = expanded_path
          break
        end
      end
      
      if api_key_path
        key_content = File.read(api_key_path)
        # Authenticate with API key first
        app_store_connect_api_key(
          key_id: api_key_id,
          issuer_id: api_key_issuer_id,
          key_content: key_content,
          is_key_content_base64: false
        )
      end
    end
    
    # Upload will use the authenticated session
    upload_to_app_store(
      ipa: ipa_path,
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false
    )
    
    UI.success("Upload complete!")
  end

  desc "Deploy to App Store (build + upload)"
  lane :deploy do
    build
    upload
  end
end
